<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EntityManager - Guia Completo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        section {
            margin-bottom: 40px;
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .highlight {
            background: #f4f4f4;
            padding: 20px;
            border-left: 4px solid #667eea;
            margin: 20px 0;
            border-radius: 5px;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .code-block code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95em;
            line-height: 1.5;
            white-space: pre;
            display: block;
        }

        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .function { color: #dcdcaa; }
        .class { color: #4ec9b0; }
        .number { color: #b5cea8; }

        .method-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #e0e0e0;
        }

        .method-card h4 {
            color: #667eea;
            margin-top: 0;
        }

        ul {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        footer {
            background: #333;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            header h1 {
                font-size: 1.8em;
            }

            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>EntityManager</h1>
            <p>Guia Completo sobre o Padr√£o de Persist√™ncia em ORMs</p>
        </header>

        <div class="content">
            <section id="introducao">
                <h2>O que √© EntityManager?</h2>
                <p>
                    O <strong>EntityManager</strong> √© um componente fundamental em ORMs (Object-Relational Mapping) que atua como uma ponte entre o c√≥digo orientado a objetos e o banco de dados relacional. Ele gerencia o ciclo de vida das entidades, rastreia mudan√ßas, e coordena a sincroniza√ß√£o entre o estado das entidades na mem√≥ria e suas representa√ß√µes no banco de dados.
                </p>

                <div class="highlight">
                    <h4>Responsabilidades Principais:</h4>
                    <ul>
                        <li><strong>Persist√™ncia:</strong> Salvar novas entidades no banco de dados</li>
                        <li><strong>Recupera√ß√£o:</strong> Buscar entidades existentes</li>
                        <li><strong>Atualiza√ß√£o:</strong> Sincronizar mudan√ßas das entidades com o banco</li>
                        <li><strong>Remo√ß√£o:</strong> Excluir entidades do banco de dados</li>
                        <li><strong>Gerenciamento de Transa√ß√µes:</strong> Coordenar opera√ß√µes dentro de transa√ß√µes</li>
                        <li><strong>Identity Map:</strong> Garantir que apenas uma inst√¢ncia de cada entidade existe no contexto</li>
                        <li><strong>Unit of Work:</strong> Rastrear mudan√ßas e otimizar opera√ß√µes de escrita</li>
                    </ul>
                </div>
            </section>

            <section id="ciclo-vida">
                <h2>Ciclo de Vida das Entidades</h2>
                <p>
                    As entidades gerenciadas pelo EntityManager passam por diferentes estados durante seu ciclo de vida:
                </p>

                <div class="method-card">
                    <h4>1. New/Transient (Novo/Transit√≥rio)</h4>
                    <p>
                        Objeto criado com <code>new
</code> mas ainda n√£o gerenciado pelo EntityManager. Mudan√ßas neste objeto n√£o s√£o rastreadas e ele n√£o ser√° persistido automaticamente.
                    </p>
                    <div class="code-block">
<code><span class="comment">// Objeto no estado Transient</span>
<span class="keyword">const</span> user = <span class="keyword">new</span> <span class="class">User</span>();
user.name = <span class="string">'Jo√£o'</span>; <span class="comment">// Mudan√ßas n√£o s√£o rastreadas</span>

</code>
                    </div>
                </div>

                <div class="method-card">
                    <h4>2. Managed/Persistent (Gerenciado/Persistente)</h4>
                    <p>
                        Objeto gerenciado pelo EntityManager. Mudan√ßas s√£o automaticamente rastreadas (dirty checking) e ser√£o sincronizadas com o banco no pr√≥ximo <code>flush()
</code>.
                    </p>
                    <div class="code-block">
<code><span class="comment">// Tornar objeto Managed</span>
em.<span class="function">persist</span>(user); <span class="comment">// Agora est√° gerenciado</span>
user.name = <span class="string">'Jo√£o Silva'</span>; <span class="comment">// Mudan√ßa rastreada automaticamente</span>
<span class="keyword">await</span> em.<span class="function">flush</span>(); <span class="comment">// Mudan√ßas sincronizadas com o banco</span>

</code>
                    </div>
                </div>

                <div class="method-card">
                    <h4>3. Detached (Desanexado)</h4>
                    <p>
                        Objeto que foi gerenciado anteriormente mas foi removido do contexto (via <code>clear()
</code> ou quando o EntityManager √© fechado). Mudan√ßas n√£o s√£o mais rastreadas.
                    </p>
                    <div class="code-block">
<code><span class="keyword">const</span> user = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>); <span class="comment">// Managed</span>
em.<span class="function">clear</span>(); <span class="comment">// Agora user est√° Detached</span>
user.name = <span class="string">'Novo Nome'</span>; <span class="comment">// Mudan√ßa N√ÉO ser√° persistida</span>

<span class="comment">// Para reanexa ao contexto:</span>
em.<span class="function">merge</span>(user); <span class="comment">// Volta a ser Managed</span>

</code>
                    </div>
                </div>

                <div class="method-card">
                    <h4>4. Removed (Removido)</h4>
                    <p>
                        Objeto marcado para remo√ß√£o. Ser√° deletado do banco no pr√≥ximo <code>flush()
</code>.
                    </p>
                    <div class="code-block">
<code><span class="keyword">const</span> user = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);
em.<span class="function">remove</span>(user); <span class="comment">// Marcado para remo√ß√£o</span>
<span class="keyword">await</span> em.<span class="function">flush</span>(); <span class="comment">// DELETE executado no banco</span>

</code>
                    </div>
                </div>

                <div class="info">
                    <strong>üí° Diagrama de Estados:</strong>
                    <p style="font-family: monospace; margin-top: 10px;">
                        New ‚Üí [persist()] ‚Üí Managed ‚Üí [remove()] ‚Üí Removed ‚Üí [flush()] ‚Üí Deleted<br>
                        Managed ‚Üí [clear()/detach()] ‚Üí Detached ‚Üí [merge()] ‚Üí Managed<br>
                        Detached ‚Üí [persist()] ‚Üí Managed
                    </p>
                </div>
            </section>

            <section id="unit-of-work">
                <h2>Unit of Work Pattern</h2>
                <p>
                    O <strong>Unit of Work</strong> √© um padr√£o fundamental implementado pelo EntityManager que mant√©m uma lista de objetos afetados por uma transa√ß√£o de neg√≥cio e coordena a escrita das mudan√ßas.
                </p>

                <div class="highlight">
                    <h4>Como funciona:</h4>
                    <ul>
                        <li><strong>Rastreamento de Mudan√ßas:</strong> O EntityManager mant√©m um snapshot do estado original de cada entidade gerenciada</li>
                        <li><strong>Dirty Checking:</strong> No flush(), compara o estado atual com o snapshot para detectar mudan√ßas</li>
                        <li><strong>Otimiza√ß√£o:</strong> Agrupa opera√ß√µes SQL em batch para melhor performance</li>
                        <li><strong>Ordena√ß√£o:</strong> Garante a ordem correta de INSERTs, UPDATEs e DELETEs para evitar viola√ß√£o de constraints</li>
                    </ul>
                </div>

                <div class="code-block">
<code><span class="comment">// Unit of Work em a√ß√£o</span>
<span class="keyword">const</span> em = orm.em.<span class="function">fork</span>();

<span class="comment">// 1. Criar novas entidades</span>
<span class="keyword">const</span> user1 = <span class="keyword">new</span> <span class="class">User</span>();
user1.name = <span class="string">'Jo√£o'</span>;
em.<span class="function">persist</span>(user1); <span class="comment">// Adicionado ao Unit of Work</span>

<span class="keyword">const</span> user2 = <span class="keyword">new</span> <span class="class">User</span>();
user2.name = <span class="string">'Maria'</span>;
em.<span class="function">persist</span>(user2); <span class="comment">// Adicionado ao Unit of Work</span>

<span class="comment">// 2. Modificar entidades existentes</span>
<span class="keyword">const</span> user3 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">3</span>);
user3.name = <span class="string">'Pedro Atualizado'</span>; <span class="comment">// Mudan√ßa rastreada</span>

<span class="comment">// 3. Remover entidades</span>
<span class="keyword">const</span> user4 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">4</span>);
em.<span class="function">remove</span>(user4); <span class="comment">// Marcado para remo√ß√£o</span>

<span class="comment">// 4. Flush - Unit of Work executa TODAS as opera√ß√µes</span>
<span class="comment">//    em uma ordem otimizada:</span>
<span class="comment">//    - INSERTs primeiro (user1, user2)</span>
<span class="comment">//    - UPDATEs depois (user3)</span>
<span class="comment">//    - DELETEs por √∫ltimo (user4)</span>
<span class="keyword">await</span> em.<span class="function">flush</span>();
</code>
                </div>

                <div class="warning">
                    <strong>‚ö†Ô∏è Performance:</strong> O Unit of Work mant√©m refer√™ncias a todas as entidades gerenciadas. Em opera√ß√µes com muitos dados, use <code>flush()
</code> + <code>clear()
</code> periodicamente para liberar mem√≥ria.
                </div>
            </section>

            <section id="identity-map">
                <h2>Identity Map Pattern</h2>
                <p>
                    O <strong>Identity Map</strong> √© um cache de primeiro n√≠vel que garante que existe apenas uma inst√¢ncia de cada entidade no contexto do EntityManager. Isso previne problemas de consist√™ncia e reduz queries ao banco.
                </p>

                <div class="highlight">
                    <h4>Benef√≠cios:</h4>
                    <ul>
                        <li><strong>Consist√™ncia:</strong> M√∫ltiplas refer√™ncias √† mesma entidade apontam para o mesmo objeto</li>
                        <li><strong>Performance:</strong> Evita queries duplicadas ao banco de dados</li>
                        <li><strong>Integridade:</strong> Mudan√ßas em uma refer√™ncia afetam todas as outras automaticamente</li>
                    </ul>
                </div>

                <div class="code-block">
<code><span class="comment">// Identity Map em a√ß√£o</span>
<span class="keyword">const</span> em = orm.em.<span class="function">fork</span>();

<span class="comment">// Primeira busca - vai ao banco de dados</span>
<span class="keyword">const</span> user1 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);
console.<span class="function">log</span>(user1.name); <span class="comment">// "Jo√£o"</span>

<span class="comment">// Segunda busca - retorna a MESMA inst√¢ncia do cache</span>
<span class="keyword">const</span> user2 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);

<span class="comment">// user1 e user2 s√£o a MESMA inst√¢ncia!</span>
console.<span class="function">log</span>(user1 === user2); <span class="comment">// true</span>

<span class="comment">// Mudan√ßa em uma afeta a outra</span>
user1.name = <span class="string">'Jo√£o Silva'</span>;
console.<span class="function">log</span>(user2.name); <span class="comment">// "Jo√£o Silva"</span>

<span class="comment">// Apenas UM UPDATE ser√° executado</span>
<span class="keyword">await</span> em.<span class="function">flush</span>();
</code>
                </div>

                <div class="info">
                    <strong>‚ÑπÔ∏è Limpando o Identity Map:</strong> Use <code>em.clear()
</code> para limpar o cache e for√ßar novas queries ao banco. √ötil quando voc√™ precisa garantir que est√° lendo dados frescos ou para liberar mem√≥ria.
                </div>

                <div class="code-block">
<code><span class="comment">// For√ßar releitura do banco de dados</span>
<span class="keyword">const</span> user1 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);
console.<span class="function">log</span>(user1.name); <span class="comment">// "Jo√£o"</span>

<span class="comment">// Limpar o Identity Map</span>
em.<span class="function">clear</span>();

<span class="comment">// Nova busca vai ao banco novamente</span>
<span class="keyword">const</span> user2 = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);
console.<span class="function">log</span>(user1 === user2); <span class="comment">// false - inst√¢ncias diferentes!</span>
</code>
                </div>
            </section>

            <section id="flush">
                <h2>M√©todo flush()</h2>

                <div class="method-card">
                    <h4>Defini√ß√£o</h4>
                    <p>
                        O m√©todo <code>flush()
</code> for√ßa o EntityManager a sincronizar todas as mudan√ßas pendentes das entidades gerenciadas com o banco de dados. Ele executa os comandos SQL (INSERT, UPDATE, DELETE) sem necessariamente fazer commit da transa√ß√£o.
                    </p>
                </div>

                <h3>Quando usar flush()?</h3>
                <ul>
                    <li>Quando voc√™ precisa garantir que as mudan√ßas sejam enviadas ao banco antes de executar queries nativas</li>
                    <li>Para obter IDs gerados pelo banco de dados imediatamente</li>
                    <li>Para validar constraints do banco antes do commit final</li>
                    <li>Em opera√ß√µes batch para liberar mem√≥ria periodicamente</li>
                </ul>

                <h3>Exemplo em Java com Hibernate</h3>
                <div class="code-block">
<code><span class="keyword">import</span> javax.persistence.*;

<span class="keyword">public class</span> <span class="class">UserService</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="keyword">private</span> <span class="class">EntityManager</span> em;

    <span class="keyword">public void</span> <span class="function">createUsersInBatch</span>(<span class="class">List</span>&lt;<span class="class">User</span>&gt; users) {
        <span class="keyword">int</span> batchSize = <span class="number">50</span>;

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.size(); i++) {
            <span class="class">User</span> user = users.get(i);
            em.<span class="function">persist</span>(user);

            <span class="comment">// Flush a cada 50 registros para liberar mem√≥ria</span>
            <span class="keyword">if</span> (i % batchSize == <span class="number">0</span> && i &gt; <span class="number">0</span>) {
                em.<span class="function">flush</span>();
                em.<span class="function">clear</span>(); <span class="comment">// Limpa o contexto</span>
            }
        }

        <span class="comment">// Flush final para os registros restantes</span>
        em.<span class="function">flush</span>();
    }

    <span class="keyword">public void</span> <span class="function">updateUserAndGetId</span>() {
        <span class="class">User</span> user = <span class="keyword">new</span> <span class="class">User</span>();
        user.<span class="function">setName</span>(<span class="string">"Jo√£o Silva"</span>);
        user.<span class="function">setEmail</span>(<span class="string">"joao@email.com"</span>);

        em.<span class="function">persist</span>(user);

        <span class="comment">// Flush para for√ßar o INSERT e obter o ID gerado</span>
        em.<span class="function">flush</span>();

        <span class="class">Long</span> userId = user.<span class="function">getId</span>();
        <span class="class">System</span>.out.<span class="function">println</span>(<span class="string">"ID gerado: "</span> + userId);

        <span class="comment">// Agora podemos usar o ID em uma query nativa</span>
        em.<span class="function">createNativeQuery</span>(
            <span class="string">"INSERT INTO user_audit (user_id, action) VALUES (?, ?)"</span>
        )
        .<span class="function">setParameter</span>(<span class="number">1</span>, userId)
        .<span class="function">setParameter</span>(<span class="number">2</span>, <span class="string">"CREATED"</span>)
        .<span class="function">executeUpdate</span>();
    }
}
</code>
                </div>

                <h3>Exemplo em TypeScript com MikroORM</h3>
                <div class="code-block">
<code><span class="keyword">import</span> { <span class="class">EntityManager</span> } <span class="keyword">from</span> <span class="string">'@mikro-orm/core'</span>;
<span class="keyword">import</span> { <span class="class">User</span> } <span class="keyword">from</span> <span class="string">'./entities/User'</span>;

<span class="keyword">export class</span> <span class="class">UserService</span> {
    <span class="keyword">constructor</span>(<span class="keyword">private</span> em: <span class="class">EntityManager</span>) {}

    <span class="keyword">async</span> <span class="function">createUsersInBatch</span>(users: <span class="class">User</span>[]): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="keyword">const</span> batchSize = <span class="number">50</span>;

        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.length; i++) {
            <span class="keyword">const</span> user = users[i];
            <span class="keyword">this</span>.em.<span class="function">persist</span>(user);

            <span class="comment">// Flush a cada 50 registros</span>
            <span class="keyword">if</span> (i % batchSize === <span class="number">0</span> && i &gt; <span class="number">0</span>) {
                <span class="keyword">await this</span>.em.<span class="function">flush</span>();
                <span class="keyword">this</span>.em.<span class="function">clear</span>(); <span class="comment">// Limpa o contexto</span>
            }
        }

        <span class="comment">// Flush final</span>
        <span class="keyword">await this</span>.em.<span class="function">flush</span>();
    }

    <span class="keyword">async</span> <span class="function">updateUserAndGetId</span>(): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="class">User</span>();
        user.name = <span class="string">'Jo√£o Silva'</span>;
        user.email = <span class="string">'joao@email.com'</span>;

        <span class="keyword">this</span>.em.<span class="function">persist</span>(user);

        <span class="comment">// Flush para for√ßar o INSERT e obter o ID gerado</span>
        <span class="keyword">await this</span>.em.<span class="function">flush</span>();

        <span class="keyword">const</span> userId = user.id;
        console.<span class="function">log</span>(<span class="string">`ID gerado: ${userId}`</span>);

        <span class="comment">// Agora podemos usar o ID em uma query nativa</span>
        <span class="keyword">await this</span>.em.<span class="function">getConnection</span>().<span class="function">execute</span>(
            <span class="string">'INSERT INTO user_audit (user_id, action) VALUES (?, ?)'</span>,
            [userId, <span class="string">'CREATED'</span>]
        );
    }

    <span class="keyword">async</span> <span class="function">demonstrateFlushModes</span>(): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="comment">// MikroORM suporta diferentes modos de flush</span>
        <span class="keyword">const</span> user = <span class="keyword">await this</span>.em.<span class="function">findOne</span>(<span class="class">User</span>, { email: <span class="string">'joao@email.com'</span> });

        <span class="keyword">if</span> (user) {
            user.name = <span class="string">'Jo√£o da Silva'</span>;

            <span class="comment">// Flush autom√°tico ocorre no commit da transa√ß√£o</span>
            <span class="comment">// Mas podemos for√ßar manualmente:</span>
            <span class="keyword">await this</span>.em.<span class="function">flush</span>();
        }
    }
}
</code>
                </div>

                <div class="warning">
                    <strong>‚ö†Ô∏è Aten√ß√£o:</strong> Usar <code>flush()
</code> excessivamente pode impactar a performance, pois impede que o ORM otimize as opera√ß√µes em batch. Use apenas quando realmente necess√°rio.
                </div>
            </section>

            <section id="clear">
                <h2>M√©todo clear()</h2>

                <div class="method-card">
                    <h4>Defini√ß√£o</h4>
                    <p>
                        O m√©todo <code>clear()
</code> remove todas as entidades do contexto do EntityManager, desanexando-as (tornando-as detached). Isso limpa o cache de primeiro n√≠vel (Identity Map) sem afetar o banco de dados.
                    </p>
                </div>

                <h3>Quando usar clear()?</h3>
                <ul>
                    <li>Para liberar mem√≥ria em opera√ß√µes com muitas entidades (batch processing)</li>
                    <li>Para for√ßar uma releitura do banco de dados (evitar cache)</li>
                    <li>Quando voc√™ precisa descartar mudan√ßas n√£o persistidas</li>
                    <li>Para evitar problemas de mem√≥ria em loops longos</li>
                </ul>

                <h3>Exemplo em Java com Hibernate</h3>
                <div class="code-block">
<code><span class="keyword">import</span> javax.persistence.*;

<span class="keyword">public class</span> <span class="class">ReportService</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="keyword">private</span> <span class="class">EntityManager</span> em;

    <span class="keyword">public void</span> <span class="function">processMassiveReport</span>() {
        <span class="class">List</span>&lt;<span class="class">Transaction</span>&gt; transactions =
            em.<span class="function">createQuery</span>(<span class="string">"SELECT t FROM Transaction t"</span>, <span class="class">Transaction</span>.<span class="keyword">class</span>)
              .<span class="function">getResultList</span>();

        <span class="keyword">int</span> count = <span class="number">0</span>;

        <span class="keyword">for</span> (<span class="class">Transaction</span> transaction : transactions) {
            <span class="comment">// Processar transa√ß√£o</span>
            transaction.<span class="function">setProcessed</span>(<span class="keyword">true</span>);

            count++;

            <span class="comment">// A cada 100 registros, sincroniza e limpa</span>
            <span class="keyword">if</span> (count % <span class="number">100</span> == <span class="number">0</span>) {
                em.<span class="function">flush</span>();  <span class="comment">// Persiste as mudan√ßas</span>
                em.<span class="function">clear</span>();  <span class="comment">// Limpa o contexto para liberar mem√≥ria</span>
            }
        }

        <span class="comment">// Flush final</span>
        em.<span class="function">flush</span>();
    }

    <span class="keyword">public</span> <span class="class">User</span> <span class="function">forceRefreshFromDatabase</span>(<span class="class">Long</span> userId) {
        <span class="comment">// Buscar usu√°rio (pode estar em cache)</span>
        <span class="class">User</span> user = em.<span class="function">find</span>(<span class="class">User</span>.<span class="keyword">class</span>, userId);

        <span class="comment">// Limpar o contexto para desanexar a entidade</span>
        em.<span class="function">clear</span>();

        <span class="comment">// Buscar novamente - agora vem direto do banco</span>
        <span class="keyword">return</span> em.<span class="function">find</span>(<span class="class">User</span>.<span class="keyword">class</span>, userId);
    }

    <span class="keyword">public void</span> <span class="function">discardChanges</span>() {
        <span class="class">User</span> user = em.<span class="function">find</span>(<span class="class">User</span>.<span class="keyword">class</span>, <span class="number">1L</span>);
        user.<span class="function">setName</span>(<span class="string">"Nome Tempor√°rio"</span>);

        <span class="comment">// Mudan√ßas n√£o foram persistidas ainda</span>
        <span class="comment">// Clear remove a entidade do contexto, descartando mudan√ßas</span>
        em.<span class="function">clear</span>();

        <span class="comment">// Ao buscar novamente, teremos os dados originais do banco</span>
        user = em.<span class="function">find</span>(<span class="class">User</span>.<span class="keyword">class</span>, <span class="number">1L</span>);
        <span class="class">System</span>.out.<span class="function">println</span>(user.<span class="function">getName</span>()); <span class="comment">// Nome original do banco</span>
    }
}
</code>
                </div>

                <h3>Exemplo em TypeScript com MikroORM</h3>
                <div class="code-block">
<code><span class="keyword">import</span> { <span class="class">EntityManager</span> } <span class="keyword">from</span> <span class="string">'@mikro-orm/core'</span>;
<span class="keyword">import</span> { <span class="class">Transaction</span> } <span class="keyword">from</span> <span class="string">'./entities/Transaction'</span>;
<span class="keyword">import</span> { <span class="class">User</span> } <span class="keyword">from</span> <span class="string">'./entities/User'</span>;

<span class="keyword">export class</span> <span class="class">ReportService</span> {
    <span class="keyword">constructor</span>(<span class="keyword">private</span> em: <span class="class">EntityManager</span>) {}

    <span class="keyword">async</span> <span class="function">processMassiveReport</span>(): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="keyword">const</span> transactions = <span class="keyword">await this</span>.em.<span class="function">find</span>(<span class="class">Transaction</span>, {});

        <span class="keyword">let</span> count = <span class="number">0</span>;

        <span class="keyword">for</span> (<span class="keyword">const</span> transaction <span class="keyword">of</span> transactions) {
            <span class="comment">// Processar transa√ß√£o</span>
            transaction.processed = <span class="keyword">true</span>;

            count++;

            <span class="comment">// A cada 100 registros, sincroniza e limpa</span>
            <span class="keyword">if</span> (count % <span class="number">100</span> === <span class="number">0</span>) {
                <span class="keyword">await this</span>.em.<span class="function">flush</span>();  <span class="comment">// Persiste as mudan√ßas</span>
                <span class="keyword">this</span>.em.<span class="function">clear</span>();          <span class="comment">// Limpa o contexto</span>
            }
        }

        <span class="comment">// Flush final</span>
        <span class="keyword">await this</span>.em.<span class="function">flush</span>();
    }

    <span class="keyword">async</span> <span class="function">forceRefreshFromDatabase</span>(userId: <span class="keyword">number</span>): <span class="class">Promise</span>&lt;<span class="class">User</span> | <span class="keyword">null</span>&gt; {
        <span class="comment">// Buscar usu√°rio (pode estar em cache)</span>
        <span class="keyword">let</span> user = <span class="keyword">await this</span>.em.<span class="function">findOne</span>(<span class="class">User</span>, userId);

        <span class="comment">// Limpar o contexto para desanexar a entidade</span>
        <span class="keyword">this</span>.em.<span class="function">clear</span>();

        <span class="comment">// Buscar novamente - agora vem direto do banco</span>
        <span class="keyword">return await this</span>.em.<span class="function">findOne</span>(<span class="class">User</span>, userId);
    }

    <span class="keyword">async</span> <span class="function">discardChanges</span>(): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="keyword">const</span> user = <span class="keyword">await this</span>.em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);

        <span class="keyword">if</span> (user) {
            user.name = <span class="string">'Nome Tempor√°rio'</span>;

            <span class="comment">// Mudan√ßas n√£o foram persistidas ainda</span>
            <span class="comment">// Clear remove a entidade do contexto, descartando mudan√ßas</span>
            <span class="keyword">this</span>.em.<span class="function">clear</span>();

            <span class="comment">// Ao buscar novamente, teremos os dados originais do banco</span>
            <span class="keyword">const</span> freshUser = <span class="keyword">await this</span>.em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);
            console.<span class="function">log</span>(freshUser?.name); <span class="comment">// Nome original do banco</span>
        }
    }

    <span class="keyword">async</span> <span class="function">demonstrateClearWithFork</span>(): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="comment">// MikroORM oferece fork() como alternativa ao clear()</span>
        <span class="comment">// fork() cria um novo EntityManager com contexto limpo</span>
        <span class="keyword">const</span> forkedEm = <span class="keyword">this</span>.em.<span class="function">fork</span>();

        <span class="comment">// Trabalhar com o contexto limpo</span>
        <span class="keyword">const</span> users = <span class="keyword">await</span> forkedEm.<span class="function">find</span>(<span class="class">User</span>, {});

        <span class="comment">// O EntityManager original permanece inalterado</span>
    }
}
</code>
                </div>

                <div class="info">
                    <strong>‚ÑπÔ∏è Dica:</strong> No MikroORM, voc√™ tamb√©m pode usar <code>em.fork()
</code> para criar um novo contexto isolado sem limpar o original, √∫til para opera√ß√µes paralelas ou isolamento de contexto.
                </div>
            </section>

            <section id="flush-clear-juntos">
                <h2>Usando flush() e clear() Juntos</h2>

                <p>
                    A combina√ß√£o de <code>flush()
</code> e <code>clear()
</code> √© extremamente √∫til em opera√ß√µes batch, onde voc√™ processa grandes volumes de dados. O padr√£o √©:
                </p>

                <div class="highlight">
                    <ol>
                        <li><strong>Modificar</strong> entidades no contexto</li>
                        <li><strong>flush()</strong> - Sincronizar mudan√ßas com o banco</li>
                        <li><strong>clear()</strong> - Limpar o contexto para liberar mem√≥ria</li>
                        <li><strong>Repetir</strong> o processo</li>
                    </ol>
                </div>

                <h3>Exemplo Completo de Batch Processing</h3>

                <h4>Java com Hibernate</h4>
                <div class="code-block">
<code><span class="keyword">public class</span> <span class="class">BatchProcessor</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="keyword">private</span> <span class="class">EntityManager</span> em;

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">importCustomersFromCSV</span>(<span class="class">List</span>&lt;<span class="class">String</span>[]&gt; csvData) {
        <span class="keyword">int</span> batchSize = <span class="number">50</span>;

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; csvData.size(); i++) {
            <span class="class">String</span>[] row = csvData.get(i);

            <span class="class">Customer</span> customer = <span class="keyword">new</span> <span class="class">Customer</span>();
            customer.<span class="function">setName</span>(row[<span class="number">0</span>]);
            customer.<span class="function">setEmail</span>(row[<span class="number">1</span>]);
            customer.<span class="function">setPhone</span>(row[<span class="number">2</span>]);

            em.<span class="function">persist</span>(customer);

            <span class="keyword">if</span> ((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>) {
                <span class="comment">// Sincroniza com o banco</span>
                em.<span class="function">flush</span>();

                <span class="comment">// Limpa o contexto para liberar mem√≥ria</span>
                em.<span class="function">clear</span>();

                <span class="class">System</span>.out.<span class="function">println</span>(<span class="string">"Processados: "</span> + (i + <span class="number">1</span>) + <span class="string">" registros"</span>);
            }
        }

        <span class="comment">// Processar registros restantes</span>
        em.<span class="function">flush</span>();
        em.<span class="function">clear</span>();
    }
}
</code>
                </div>

                <h4>TypeScript com MikroORM</h4>
                <div class="code-block">
<code><span class="keyword">export class</span> <span class="class">BatchProcessor</span> {
    <span class="keyword">constructor</span>(<span class="keyword">private</span> em: <span class="class">EntityManager</span>) {}

    <span class="keyword">async</span> <span class="function">importCustomersFromCSV</span>(csvData: <span class="keyword">string</span>[][]): <span class="class">Promise</span>&lt;<span class="keyword">void</span>&gt; {
        <span class="keyword">const</span> batchSize = <span class="number">50</span>;

        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; csvData.length; i++) {
            <span class="keyword">const</span> row = csvData[i];

            <span class="keyword">const</span> customer = <span class="keyword">new</span> <span class="class">Customer</span>();
            customer.name = row[<span class="number">0</span>];
            customer.email = row[<span class="number">1</span>];
            customer.phone = row[<span class="number">2</span>];

            <span class="keyword">this</span>.em.<span class="function">persist</span>(customer);

            <span class="keyword">if</span> ((i + <span class="number">1</span>) % batchSize === <span class="number">0</span>) {
                <span class="comment">// Sincroniza com o banco</span>
                <span class="keyword">await this</span>.em.<span class="function">flush</span>();

                <span class="comment">// Limpa o contexto para liberar mem√≥ria</span>
                <span class="keyword">this</span>.em.<span class="function">clear</span>();

                console.<span class="function">log</span>(<span class="string">`Processados: ${i + 1} registros`</span>);
            }
        }

        <span class="comment">// Processar registros restantes</span>
        <span class="keyword">await this</span>.em.<span class="function">flush</span>();
        <span class="keyword">this</span>.em.<span class="function">clear</span>();
    }
}
</code>
                </div>
            </section>

            <section id="outros-metodos">
                <h2>Outros M√©todos Importantes do EntityManager</h2>

                <div class="method-card">
                    <h4>persist(entity)</h4>
                    <p>Adiciona uma nova entidade ao contexto para ser inserida no banco no pr√≥ximo flush.</p>
                </div>

                <div class="method-card">
                    <h4>merge(entity)</h4>
                    <p>Reanexa uma entidade detached ao contexto, sincronizando suas mudan√ßas.</p>
                </div>

                <div class="method-card">
                    <h4>remove(entity)</h4>
                    <p>Marca uma entidade para remo√ß√£o do banco no pr√≥ximo flush.</p>
                </div>

                <div class="method-card">
                    <h4>find(entityClass, id)</h4>
                    <p>Busca uma entidade por sua chave prim√°ria.</p>
                </div>

                <div class="method-card">
                    <h4>refresh(entity)</h4>
                    <p>Recarrega o estado da entidade do banco, descartando mudan√ßas n√£o persistidas.</p>
                </div>

                <div class="method-card">
                    <h4>detach(entity)</h4>
                    <p>Remove uma entidade espec√≠fica do contexto (diferente de clear que remove todas).</p>
                </div>
            </section>

            <section id="melhores-praticas">
                <h2>Melhores Pr√°ticas</h2>

                <div class="highlight">
                    <h4>‚úÖ Boas Pr√°ticas</h4>
                    <ul>
                        <li>Use <code>flush()
</code> e <code>clear()
</code> em batch processing para gerenciar mem√≥ria</li>
                        <li>Mantenha transa√ß√µes curtas e focadas</li>
                        <li>Use o EntityManager em um escopo apropriado (request-scoped em APIs web)</li>
                        <li>Aproveite o lazy loading quando apropriado para reduzir queries</li>
                        <li>Use queries otimizadas (JPQL/QueryBuilder) para opera√ß√µes em massa</li>
                    </ul>
                </div>

                <div class="warning">
                    <h4>‚ùå Pr√°ticas a Evitar</h4>
                    <ul>
                        <li>N√£o chame <code>flush()
</code> dentro de loops sem necessidade</li>
                        <li>N√£o mantenha EntityManager aberto por muito tempo (memory leaks)</li>
                        <li>Evite N+1 queries - use joins ou eager loading quando necess√°rio</li>
                        <li>N√£o ignore exce√ß√µes de otimistic locking</li>
                        <li>N√£o use EntityManager em contextos multi-thread sem cuidado</li>
                    </ul>
                </div>
            </section>

            <section id="active-record-vs-data-mapper">
                <h2>Active Record vs Data Mapper</h2>

                <p>
                    Existem duas abordagens principais de padr√µes de persist√™ncia em ORMs: <strong>Active Record</strong> e <strong>Data Mapper</strong>. Cada uma tem suas caracter√≠sticas, vantagens e casos de uso ideais.
                </p>

                <h3>Active Record Pattern</h3>

                <div class="highlight">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>A entidade possui m√©todos para salvar, atualizar e excluir a si mesma</li>
                        <li>Cada entidade "sabe" como se persistir no banco de dados</li>
                        <li>Acoplamento direto entre modelo de dom√≠nio e l√≥gica de persist√™ncia</li>
                        <li>API mais simples e intuitiva para opera√ß√µes CRUD b√°sicas</li>
                    </ul>
                </div>

                <h4>Exemplo com TypeORM (Active Record)</h4>
                <div class="code-block">
<code><span class="keyword">import</span> { <span class="class">BaseEntity</span>, <span class="class">Entity</span>, <span class="class">PrimaryGeneratedColumn</span>, <span class="class">Column</span> } <span class="keyword">from</span> <span class="string">'typeorm'</span>;

<span class="annotation">@Entity</span>()
<span class="keyword">export class</span> <span class="class">User</span> <span class="keyword">extends</span> <span class="class">BaseEntity</span> {
    <span class="annotation">@PrimaryGeneratedColumn</span>()
    id: <span class="keyword">number</span>;

    <span class="annotation">@Column</span>()
    name: <span class="keyword">string</span>;

    <span class="annotation">@Column</span>()
    email: <span class="keyword">string</span>;
}

<span class="comment">// Uso do Active Record</span>
<span class="keyword">const</span> user = <span class="keyword">new</span> <span class="class">User</span>();
user.name = <span class="string">'Jo√£o Silva'</span>;
user.email = <span class="string">'joao@email.com'</span>;

<span class="comment">// A entidade sabe como se salvar</span>
<span class="keyword">await</span> user.<span class="function">save</span>();

<span class="comment">// Buscar entidades</span>
<span class="keyword">const</span> users = <span class="keyword">await</span> <span class="class">User</span>.<span class="function">find</span>();
<span class="keyword">const</span> userById = <span class="keyword">await</span> <span class="class">User</span>.<span class="function">findOne</span>({ where: { id: <span class="number">1</span> } });

<span class="comment">// Atualizar</span>
user.name = <span class="string">'Jo√£o da Silva'</span>;
<span class="keyword">await</span> user.<span class="function">save</span>();

<span class="comment">// Remover</span>
<span class="keyword">await</span> user.<span class="function">remove</span>();
</code>
                </div>

                <h3>Data Mapper Pattern</h3>

                <div class="highlight">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>Separa√ß√£o completa entre entidades e l√≥gica de persist√™ncia</li>
                        <li>Entidades s√£o POJOs/POTOs (Plain Old Java/TypeScript Objects) sem depend√™ncias do ORM</li>
                        <li>EntityManager/Repository √© respons√°vel pela persist√™ncia</li>
                        <li>Melhor para aplica√ß√µes com regras de neg√≥cio complexas (Domain-Driven Design)</li>
                        <li>Facilita testes unit√°rios (entidades n√£o dependem de infraestrutura)</li>
                    </ul>
                </div>

                <h4>Exemplo com MikroORM (Data Mapper)</h4>
                <div class="code-block">
<code><span class="keyword">import</span> { <span class="class">Entity</span>, <span class="class">PrimaryKey</span>, <span class="class">Property</span> } <span class="keyword">from</span> <span class="string">'@mikro-orm/core'</span>;
<span class="keyword">import</span> { <span class="class">EntityManager</span> } <span class="keyword">from</span> <span class="string">'@mikro-orm/mysql'</span>;

<span class="annotation">@Entity</span>()
<span class="keyword">export class</span> <span class="class">User</span> {
    <span class="annotation">@PrimaryKey</span>()
    id!: <span class="keyword">number</span>;

    <span class="annotation">@Property</span>()
    name!: <span class="keyword">string</span>;

    <span class="annotation">@Property</span>()
    email!: <span class="keyword">string</span>;

    <span class="comment">// Entidade N√ÉO possui m√©todos de persist√™ncia</span>
    <span class="comment">// Pode ter apenas l√≥gica de dom√≠nio</span>
    <span class="function">getDisplayName</span>(): <span class="keyword">string</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();
    }
}

<span class="comment">// Uso do Data Mapper - EntityManager gerencia a persist√™ncia</span>
<span class="keyword">const</span> em: <span class="class">EntityManager</span> = <span class="comment">/* obter do contexto */</span>;

<span class="keyword">const</span> user = <span class="keyword">new</span> <span class="class">User</span>();
user.name = <span class="string">'Jo√£o Silva'</span>;
user.email = <span class="string">'joao@email.com'</span>;

<span class="comment">// EntityManager √© respons√°vel por persistir</span>
em.<span class="function">persist</span>(user);
<span class="keyword">await</span> em.<span class="function">flush</span>();

<span class="comment">// Buscar entidades via EntityManager</span>
<span class="keyword">const</span> users = <span class="keyword">await</span> em.<span class="function">find</span>(<span class="class">User</span>, {});
<span class="keyword">const</span> userById = <span class="keyword">await</span> em.<span class="function">findOne</span>(<span class="class">User</span>, <span class="number">1</span>);

<span class="comment">// Atualizar (mudan√ßas s√£o rastreadas automaticamente)</span>
userById.name = <span class="string">'Jo√£o da Silva'</span>;
<span class="keyword">await</span> em.<span class="function">flush</span>();

<span class="comment">// Remover via EntityManager</span>
em.<span class="function">remove</span>(user);
<span class="keyword">await</span> em.<span class="function">flush</span>();
</code>
                </div>

                <h3>Compara√ß√£o Direta</h3>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 12px; border: 1px solid #ddd;">Aspecto</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">Active Record</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">Data Mapper</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Simplicidade</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Mais simples e direto</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Requer mais c√≥digo (EntityManager)</td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Separa√ß√£o de Responsabilidades</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Entidade acoplada √† persist√™ncia</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Separa√ß√£o completa</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Testabilidade</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Dif√≠cil testar sem banco de dados</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ F√°cil criar entidades para testes</td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Domain-Driven Design</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå N√£o recomendado</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Ideal para DDD</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Curva de Aprendizado</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Mais f√°cil para iniciantes</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Requer entendimento de padr√µes</td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Aplica√ß√µes Simples</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Excelente escolha</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Pode ser overkill</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Aplica√ß√µes Complexas</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚ùå Pode ficar confuso</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">‚úÖ Escalabilidade melhor</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info">
                    <h4>üí° Quando usar cada padr√£o?</h4>
                    <p><strong>Active Record:</strong></p>
                    <ul>
                        <li>Aplica√ß√µes CRUD simples</li>
                        <li>Prot√≥tipos r√°pidos</li>
                        <li>Equipes pequenas com pouca experi√™ncia em padr√µes de design</li>
                        <li>Quando a simplicidade √© mais importante que a arquitetura</li>
                    </ul>
                    <p><strong>Data Mapper:</strong></p>
                    <ul>
                        <li>Aplica√ß√µes com regras de neg√≥cio complexas</li>
                        <li>Projetos que seguem Domain-Driven Design</li>
                        <li>Quando voc√™ precisa de entidades totalmente desacopladas</li>
                        <li>Aplica√ß√µes que exigem alta testabilidade</li>
                        <li>Sistemas que precisam escalar e evoluir ao longo do tempo</li>
                    </ul>
                </div>

                <div class="warning">
                    <strong>‚ö†Ô∏è Nota:</strong> Alguns ORMs suportam ambos os padr√µes (como TypeORM), permitindo que voc√™ escolha o mais adequado para seu projeto. MikroORM e Hibernate usam principalmente Data Mapper, enquanto ActiveRecord (Rails) e Eloquent (Laravel) usam Active Record.
                </div>
            </section>

            <section id="comparacao">
                <h2>Compara√ß√£o entre ORMs</h2>

                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 12px; border: 1px solid #ddd;">Funcionalidade</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">Hibernate (Java)</th>
                            <th style="padding: 12px; border: 1px solid #ddd;">MikroORM (TypeScript)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Flush</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.flush()
</code></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>await em.flush()
</code></td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Clear</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.clear()
</code></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.clear()
</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Persist</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.persist(entity)
</code></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.persist(entity)
</code></td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Find</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.find(Class, id)
</code></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>await em.findOne(Class, id)
</code></td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Remove</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.remove(entity)
</code></td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.remove(entity)
</code></td>
                        </tr>
                        <tr style="background: #f8f9fa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Novo Contexto</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">Criar novo EM</td>
                            <td style="padding: 12px; border: 1px solid #ddd;"><code>em.fork()
</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </div>

        <footer>
            <p>EntityManager - Gerenciamento eficiente de persist√™ncia em aplica√ß√µes ORM</p>
            <p>¬© 2025 - Guia de Refer√™ncia</p>
        </footer>
    </div>
</body>
</html>