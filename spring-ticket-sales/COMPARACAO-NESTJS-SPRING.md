# Compara√ß√£o: NestJS/TypeScript vs Spring Boot/Java

## Sistema de Venda de Ingressos - An√°lise de Implementa√ß√£o DDD

Este documento explica como os padr√µes e conceitos implementados no projeto NestJS/TypeScript seriam implementados em Spring Boot/Java.

---

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Principais Diferen√ßas Arquiteturais](#principais-diferen√ßas-arquiteturais)
3. [Compara√ß√£o Detalhada por Conceito](#compara√ß√£o-detalhada-por-conceito)
4. [O que o Spring Faz Automaticamente](#o-que-o-spring-faz-automaticamente)
5. [Estrutura de Pastas](#estrutura-de-pastas)
6. [Como Executar](#como-executar)

---

## üéØ Vis√£o Geral

### Projeto Original (NestJS/TypeScript)
- **Framework**: NestJS (Node.js)
- **ORM**: MikroORM
- **Banco**: MySQL
- **Eventos**: EventEmitter2 (biblioteca externa)
- **Filas**: Bull (Redis)
- **Mensageria**: RabbitMQ
- **Linguagem**: TypeScript

### Projeto Spring (Java)
- **Framework**: Spring Boot
- **ORM**: Spring Data JPA (Hibernate)
- **Banco**: MySQL
- **Eventos**: ApplicationEventPublisher (nativo)
- **Mensageria**: Spring AMQP (RabbitMQ)
- **Linguagem**: Java 17

---

## üîÑ Principais Diferen√ßas Arquiteturais

### 1. Inje√ß√£o de Depend√™ncia

#### NestJS
```typescript
// Usa decorators e m√≥dulos
@Module({
  providers: [
    {
      provide: 'IPartnerRepository',
      useFactory: (em: EntityManager) => new PartnerMysqlRepository(em),
      inject: [EntityManager],
    },
    PartnerService,
  ],
})
export class EventsModule {}
```

**Caracter√≠sticas:**
- Configura√ß√£o manual via m√≥dulos
- Usa factories para criar inst√¢ncias
- Precisa registrar cada provider manualmente
- Usa strings como tokens de inje√ß√£o ('IPartnerRepository')

#### Spring Boot
```java
@Repository
public interface PartnerRepository extends JpaRepository<Partner, String> {
    // Spring cria implementa√ß√£o automaticamente
}

@Service
public class PartnerApplicationService {
    // Inje√ß√£o por construtor (recomendado)
    public PartnerApplicationService(PartnerRepository partnerRepository) {
        this.partnerRepository = partnerRepository;
    }
}
```

**Caracter√≠sticas:**
- **Configura√ß√£o por anota√ß√µes** (@Service, @Repository, @Component)
- **Component scan autom√°tico** - Spring encontra os beans sozinho
- **N√£o precisa de factories** para casos simples
- **Inje√ß√£o por tipo**, n√£o por string

**‚úÖ Vantagem Spring**: Menos c√≥digo boilerplate, configura√ß√£o mais simples.

---

### 2. Persist√™ncia / ORM

#### NestJS + MikroORM
```typescript
// 1. Define a entidade de dom√≠nio
export class Partner extends AggregateRoot {
  id: PartnerId;
  name: string;
}

// 2. Cria um schema SEPARADO para mapeamento
export const PartnerSchema = new EntitySchema({
  class: Partner,
  tableName: 'partners',
  properties: {
    partner_id: { type: 'uuid', primary: true },
    name: { type: 'string', length: 255 },
  },
});

// 3. Implementa reposit√≥rio manualmente
export class PartnerMysqlRepository implements IPartnerRepository {
  constructor(private em: EntityManager) {}

  async add(partner: Partner): Promise<void> {
    await this.em.persistAndFlush(partner);
  }

  async findById(id: string): Promise<Partner | null> {
    return await this.em.findOne(Partner, { partner_id: id });
  }

  async findAll(): Promise<Partner[]> {
    return await this.em.find(Partner, {});
  }
}
```

**Caracter√≠sticas:**
- **Separa√ß√£o** entre entidade de dom√≠nio e schema de persist√™ncia
- **Implementa√ß√£o manual** de todos os m√©todos do reposit√≥rio
- **EntityManager** precisa ser usado explicitamente
- Precisa chamar `persistAndFlush()` ou `flush()` manualmente

#### Spring Boot + JPA
```java
// 1. Entidade com anota√ß√µes JPA
@Entity
@Table(name = "partners")
public class Partner extends AggregateRoot {
    @Id
    @Column(name = "id")
    private String id;

    @Column(name = "name", nullable = false)
    private String name;
}

// 2. Repository interface - Spring gera implementa√ß√£o!
@Repository
public interface PartnerRepository extends JpaRepository<Partner, String> {
    // M√©todos dispon√≠veis AUTOMATICAMENTE:
    // - save(Partner)
    // - findById(String)
    // - findAll()
    // - delete(Partner)
    // - count()
    // - existsById(String)
    // E muitos mais!

    // Queries personalizadas por conven√ß√£o de nome
    Optional<Partner> findByName(String name);
}
```

**Caracter√≠sticas:**
- **Anota√ß√µes JPA** diretamente na entidade (ou pode separar se preferir)
- **Zero implementa√ß√£o** necess√°ria para opera√ß√µes CRUD b√°sicas
- **Spring Data JPA** gera implementa√ß√£o em tempo de execu√ß√£o
- **Queries derivadas** do nome do m√©todo
- **Dirty checking** autom√°tico - mudan√ßas s√£o detectadas e persistidas

**‚úÖ Vantagem Spring**:
- 90% menos c√≥digo para reposit√≥rios
- M√©todos CRUD j√° prontos
- Queries autom√°ticas por nome do m√©todo

---

### 3. Gerenciamento de Transa√ß√µes (Unit of Work)

#### NestJS
```typescript
// 1. Interface do Unit of Work
export interface IUnitOfWork {
  commit(): Promise<void>;
  rollback(): Promise<void>;
  runTransaction<T>(fn: () => Promise<T>): Promise<T>;
  getAggregateRoots(): AggregateRoot[];
}

// 2. Implementa√ß√£o com MikroORM
export class UnitOfWorkMikroOrm implements IUnitOfWork {
  constructor(private em: EntityManager) {}

  async commit(): Promise<void> {
    return this.em.flush();
  }

  async runTransaction<T>(callback: () => Promise<T>): Promise<T> {
    return this.em.transactional(callback);
  }

  getAggregateRoots(): AggregateRoot[] {
    return [
      ...this.em.getUnitOfWork().getPersistStack(),
      ...this.em.getUnitOfWork().getRemoveStack(),
    ];
  }
}

// 3. Application Service coordena manualmente
export class ApplicationService {
  constructor(
    private uow: IUnitOfWork,
    private domainEventManager: DomainEventManager
  ) {}

  async run<T>(callback: () => Promise<T>): Promise<T> {
    await this.start();
    try {
      const result = await callback();
      await this.finish(); // Publica eventos + commit
      return result;
    } catch (e) {
      await this.fail();
      throw e;
    }
  }

  async finish() {
    const aggregateRoots = this.uow.getAggregateRoots();
    // 1. Publica eventos de dom√≠nio
    for (const root of aggregateRoots) {
      await this.domainEventManager.publish(root);
    }
    // 2. Commit no banco
    await this.uow.commit();
    // 3. Publica eventos de integra√ß√£o
    for (const root of aggregateRoots) {
      await this.domainEventManager.publishForIntegrationEvent(root);
    }
  }
}

// 4. Uso nos services
export class PartnerService {
  async create(input: { name: string }) {
    return await this.applicationService.run(async () => {
      const partner = Partner.create(input);
      await this.partnerRepo.add(partner);
      return partner;
    });
  }
}
```

**Caracter√≠sticas:**
- **Gerenciamento manual** de transa√ß√µes
- **ApplicationService** coordena tudo explicitamente
- Precisa chamar `commit()` manualmente
- Controle fino sobre quando eventos s√£o publicados
- Mais c√≥digo, mas mais controle

#### Spring Boot
```java
// 1. Simplesmente use @Transactional
@Service
public class PartnerApplicationService {

    private final PartnerRepository partnerRepository;
    private final TransactionalEventPublisher eventPublisher;

    @Transactional // <- Isso √© tudo que voc√™ precisa!
    public Partner create(String name) {
        // 1. Cria entidade
        Partner partner = Partner.create(name);

        // 2. Salva no banco
        Partner saved = partnerRepository.save(partner);

        // 3. Agenda publica√ß√£o de eventos ap√≥s commit
        eventPublisher.publishAfterCommit(saved);

        return saved;
    }
}

// 2. Publicador de eventos usa TransactionSynchronization
@Component
public class TransactionalEventPublisher {

    public void publishAfterCommit(AggregateRoot aggregateRoot) {
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    domainEventPublisher.publishEvents(aggregateRoot);
                }
            }
        );
    }
}
```

**Caracter√≠sticas:**
- **@Transactional** faz TUDO automaticamente:
  - Inicia transa√ß√£o ao entrar no m√©todo
  - Commit autom√°tico ao finalizar sem exce√ß√£o
  - Rollback autom√°tico se houver exce√ß√£o
  - Gerencia conex√µes com banco
- **TransactionSynchronization** garante ordem de execu√ß√£o
- **AOP (Aspect-Oriented Programming)** intercepta chamadas
- Menos c√≥digo, mais "m√°gico"

**‚úÖ Vantagem Spring**:
- 95% menos c√≥digo para gerenciar transa√ß√µes
- Sem necessidade de ApplicationService.run()
- Transa√ß√µes declarativas via anota√ß√£o

**‚ö†Ô∏è Desvantagem**:
- Menos expl√≠cito (pode parecer "m√°gico")
- Precisa entender proxies do Spring

---

### 4. Sistema de Eventos de Dom√≠nio

#### NestJS
```typescript
// 1. DomainEventManager usa EventEmitter2
export class DomainEventManager {
  domainEventsSubscriber: EventEmitter2;

  constructor() {
    this.domainEventsSubscriber = new EventEmitter2({
      wildcard: true,
    });
  }

  register(event: string, handler: any) {
    this.domainEventsSubscriber.on(event, handler);
  }

  async publish(aggregateRoot: AggregateRoot) {
    for (const event of aggregateRoot.events) {
      const eventClassName = event.constructor.name;
      await this.domainEventsSubscriber.emitAsync(eventClassName, event);
    }
  }
}

// 2. Registrar handlers no m√≥dulo
@Module({})
export class EventsModule implements OnModuleInit {
  onModuleInit() {
    this.domainEventManager.register('PartnerCreated', async (event) => {
      const handler = await this.moduleRef.resolve(MyHandler);
      await handler.handle(event);
    });
  }
}
```

**Caracter√≠sticas:**
- **EventEmitter2** biblioteca externa
- **Registro manual** de handlers no m√≥dulo
- String-based event names
- Precisa resolver handlers do container manualmente

#### Spring Boot
```java
// 1. Spring tem ApplicationEventPublisher NATIVO
@Component
public class DomainEventPublisher {

    private final ApplicationEventPublisher eventPublisher;

    public void publishEvents(AggregateRoot aggregateRoot) {
        for (DomainEvent event : aggregateRoot.getDomainEvents()) {
            eventPublisher.publishEvent(event);
        }
        aggregateRoot.clearEvents();
    }
}

// 2. Listeners usam anota√ß√µes
@Component
public class PartnerEventListener {

    // Executa AP√ìS commit da transa√ß√£o
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handlePartnerCreated(PartnerCreated event) {
        log.info("Partner created: {}", event.getPartnerId());
        // Enviar email, publicar no RabbitMQ, etc
    }
}
```

**Caracter√≠sticas:**
- **ApplicationEventPublisher** j√° vem com Spring
- **@TransactionalEventListener** garante eventos AP√ìS commit
- **Type-based** dispatch (n√£o precisa de strings)
- **Inje√ß√£o autom√°tica** de listeners
- Controle de fases da transa√ß√£o (BEFORE_COMMIT, AFTER_COMMIT, etc)

**‚úÖ Vantagens Spring**:
- Sistema de eventos nativo, n√£o precisa biblioteca externa
- Listeners registrados automaticamente
- @TransactionalEventListener garante consist√™ncia
- Menos c√≥digo boilerplate

---

### 5. Estrutura de M√≥dulos

#### NestJS
```
apps/mba-ddd-venda-ingresso/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ @core/                        # Camada de dom√≠nio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/               # AggregateRoot, Entity, etc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/          # ApplicationService
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infra/                # UnitOfWork
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ entities/         # Partner, Event, Order
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ events/           # Domain events
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ repositories/     # Interfaces
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ application/          # Services
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ infra/                # Implementa√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ database/                     # DatabaseModule
‚îÇ   ‚îú‚îÄ‚îÄ application/                  # ApplicationModule
‚îÇ   ‚îú‚îÄ‚îÄ domain-events/                # DomainEventsModule
‚îÇ   ‚îú‚îÄ‚îÄ events/                       # EventsModule (principal)
‚îÇ   ‚îî‚îÄ‚îÄ app.module.ts                 # M√≥dulo raiz
```

**Caracter√≠sticas:**
- Separa√ß√£o f√≠sica entre dom√≠nio, aplica√ß√£o e infraestrutura
- Schemas separados das entidades
- Cada m√≥dulo agrupa providers, controllers, imports, exports

#### Spring Boot
```
spring-ticket-sales/
‚îú‚îÄ‚îÄ src/main/java/com/fullcycle/ticketsales/
‚îÇ   ‚îú‚îÄ‚îÄ domain/                       # Camada de dom√≠nio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/                   # AggregateRoot, DomainEvent
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partner/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Partner.java          # Entidade (com @Entity JPA)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PartnerRepository.java # Interface Spring Data
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events/               # PartnerCreated, etc
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Order.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderRepository.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îú‚îÄ‚îÄ application/                  # Application Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partner/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PartnerApplicationService.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PartnerEventListener.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DomainEventPublisher.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransactionalEventPublisher.java
‚îÇ   ‚îú‚îÄ‚îÄ interfaces/                   # Camada de apresenta√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rest/                     # REST Controllers
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PartnerController.java
‚îÇ   ‚îî‚îÄ‚îÄ TicketSalesApplication.java   # Classe principal
```

**Caracter√≠sticas:**
- Organiza√ß√£o por pacotes (domain, application, interfaces)
- Anota√ß√µes JPA nas entidades de dom√≠nio
- Sem necessidade de m√≥dulos expl√≠citos (component scan autom√°tico)

**‚úÖ Vantagem Spring**:
- Menos arquivos de configura√ß√£o
- Component scan autom√°tico
- Mais simples de navegar

---

## ü§ñ O que o Spring Faz Automaticamente

Esta √© a parte mais importante para entender! No NestJS, voc√™ faz **manualmente** muitas coisas que o Spring faz **automaticamente**.

### 1. Reposit√≥rios (CRUD)

#### NestJS: ~50 linhas de c√≥digo
```typescript
export class PartnerMysqlRepository implements IPartnerRepository {
  constructor(private em: EntityManager) {}

  async add(partner: Partner): Promise<void> {
    await this.em.persistAndFlush(partner);
  }

  async findById(id: string): Promise<Partner | null> {
    return await this.em.findOne(Partner, { partner_id: id });
  }

  async findAll(): Promise<Partner[]> {
    return await this.em.find(Partner, {});
  }

  async delete(partner: Partner): Promise<void> {
    await this.em.removeAndFlush(partner);
  }
}
```

#### Spring: 3 linhas de c√≥digo!
```java
@Repository
public interface PartnerRepository extends JpaRepository<Partner, String> {
    // Pronto! Spring gera TUDO automaticamente
}
```

**O que Spring gera automaticamente**:
- save(Partner) - salva ou atualiza
- findById(String) - busca por ID
- findAll() - lista todos
- delete(Partner) - deleta
- count() - conta registros
- existsById(String) - verifica se existe
- E mais ~20 m√©todos!

---

### 2. Transa√ß√µes

#### NestJS: Gerenciamento manual
```typescript
// Precisa de toda essa estrutura:
export class ApplicationService {
  async run<T>(callback: () => Promise<T>): Promise<T> {
    await this.start();
    try {
      const result = await callback();
      await this.finish();
      return result;
    } catch (e) {
      await this.fail();
      throw e;
    }
  }
}

// E usar assim:
await this.applicationService.run(async () => {
  // c√≥digo aqui
});
```

#### Spring: Uma anota√ß√£o
```java
@Transactional
public Partner create(String name) {
    // Transa√ß√£o gerenciada automaticamente!
    // Commit autom√°tico ao final
    // Rollback autom√°tico se houver exce√ß√£o
}
```

---

### 3. Valida√ß√£o de Dados

#### NestJS
```typescript
export class CreatePartnerDto {
  @IsNotEmpty()
  @IsString()
  name: string;
}
```

#### Spring
```java
public class CreatePartnerRequest {
    @NotBlank(message = "Partner name is required")
    private String name;
}
```

**Ambos**: Valida√ß√£o autom√°tica com anota√ß√µes ‚úÖ

---

### 4. Serializa√ß√£o JSON

#### NestJS
```typescript
export class Partner {
  toJSON() {
    return {
      id: this.id.value,
      name: this.name,
    };
  }
}
```

#### Spring
```java
@Entity
@Getter  // Lombok gera getters
public class Partner {
    private String id;
    private String name;
    // Jackson serializa automaticamente via getters
}
```

**Spring**: N√£o precisa de m√©todo toJSON(), Jackson faz automaticamente.

---

### 5. Inje√ß√£o de Depend√™ncias

#### NestJS: Configura√ß√£o manual no m√≥dulo
```typescript
@Module({
  providers: [
    {
      provide: 'IPartnerRepository',
      useFactory: (em: EntityManager) => new PartnerMysqlRepository(em),
      inject: [EntityManager],
    },
    {
      provide: PartnerService,
      useFactory: (repo, appService) => new PartnerService(repo, appService),
      inject: ['IPartnerRepository', ApplicationService],
    },
  ],
})
export class EventsModule {}
```

#### Spring: Anota√ß√µes
```java
@Repository
public interface PartnerRepository extends JpaRepository<Partner, String> {}

@Service
public class PartnerService {
    // Inje√ß√£o autom√°tica por construtor
    public PartnerService(PartnerRepository repo) {}
}
```

**Spring**: Component scan encontra e registra automaticamente.

---

### 6. Sistema de Eventos

#### NestJS: EventEmitter2 (externa) + registro manual
```typescript
// Precisa instalar e configurar EventEmitter2
export class DomainEventManager {
  domainEventsSubscriber: EventEmitter2;

  constructor() {
    this.domainEventsSubscriber = new EventEmitter2({
      wildcard: true,
    });
  }
}

// Registrar handlers manualmente
onModuleInit() {
  this.domainEventManager.register('PartnerCreated', handler);
}
```

#### Spring: ApplicationEventPublisher (nativo)
```java
// J√° vem com Spring, s√≥ injetar
@Component
public class MyService {
    private final ApplicationEventPublisher publisher;

    public void doSomething() {
        publisher.publishEvent(new MyEvent());
    }
}

// Listeners autom√°ticos
@Component
public class MyListener {
    @EventListener
    public void handle(MyEvent event) {
        // processa
    }
}
```

---

## üìä Compara√ß√£o de Linhas de C√≥digo

Para implementar as mesmas funcionalidades:

| Funcionalidade | NestJS (TypeScript) | Spring (Java) | Redu√ß√£o |
|----------------|---------------------|---------------|---------|
| Reposit√≥rio CRUD | ~50 linhas | ~3 linhas | **94%** |
| Gerenciamento de Transa√ß√µes | ~40 linhas | ~1 anota√ß√£o | **98%** |
| Configura√ß√£o de M√≥dulos | ~100 linhas | ~0 linhas (autom√°tico) | **100%** |
| Sistema de Eventos | ~50 linhas | ~10 linhas (nativo) | **80%** |
| Configura√ß√£o de DI | ~30 linhas/entidade | ~0 linhas | **100%** |

**Total estimado**: Spring reduz em ~85-90% o c√≥digo boilerplate.

---

## üéØ Conceitos que o Spring Gerencia "Por Baixo dos Panos"

### 1. Unit of Work
- **NestJS**: Implementado manualmente com UnitOfWorkMikroOrm
- **Spring**: EntityManager do JPA faz automaticamente
  - Detecta mudan√ßas (dirty checking)
  - Agrupa opera√ß√µes em transa√ß√£o
  - Faz flush autom√°tico antes de commit

### 2. Repository Pattern
- **NestJS**: Implementa√ß√£o manual de cada m√©todo
- **Spring**: JpaRepository gera em runtime
  - Proxies din√¢micos
  - Reflection e bytecode generation
  - Query derivation a partir do nome do m√©todo

### 3. Transa√ß√µes
- **NestJS**: ApplicationService.run() manual
- **Spring**: AOP com @Transactional
  - Proxy intercepta chamadas
  - Inicia transa√ß√£o automaticamente
  - Commit/rollback baseado em exce√ß√µes

### 4. Eventos de Dom√≠nio
- **NestJS**: EventEmitter2 (biblioteca externa)
- **Spring**: ApplicationEventPublisher (nativo)
  - Pub/sub ass√≠ncrono
  - @TransactionalEventListener para consist√™ncia
  - Integrado com transa√ß√µes

### 5. Connection Pooling
- **NestJS**: Configurado manualmente
- **Spring**: HikariCP autom√°tico
  - Pool de conex√µes configurado
  - Gerenciamento de lifecycle
  - Otimiza√ß√µes autom√°ticas

### 6. Exception Handling
- **NestJS**: Filters manuais
- **Spring**: @ControllerAdvice
  - Tratamento global de exce√ß√µes
  - Convers√£o autom√°tica para HTTP status

---

## üèóÔ∏è Padr√µes DDD Implementados

Ambos os projetos implementam os mesmos padr√µes DDD:

| Padr√£o | NestJS | Spring | Observa√ß√£o |
|--------|--------|--------|------------|
| **Aggregate Root** | AggregateRoot extends Entity | AggregateRoot + @Entity | Spring adiciona JPA |
| **Domain Events** | IDomainEvent + EventEmitter2 | DomainEvent + ApplicationEventPublisher | Spring nativo |
| **Repository** | Interface + implementa√ß√£o manual | Interface JpaRepository | Spring gera autom√°tico |
| **Value Objects** | Classes TypeScript | Classes Java | Similares |
| **Application Service** | ApplicationService.run() | @Transactional | Spring autom√°tico |
| **Unit of Work** | UnitOfWorkMikroOrm | EntityManager (JPA) | Spring autom√°tico |
| **Domain Events** | Pub/Sub manual | @EventListener | Spring autom√°tico |

---

## üìÅ Estrutura de Pastas Completa

### Spring Boot (Este Projeto)
```
spring-ticket-sales/
‚îú‚îÄ‚îÄ pom.xml                                  # Maven dependencies
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/fullcycle/ticketsales/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AggregateRoot.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DomainEvent.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partner/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Partner.java         # Entidade + @Entity
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PartnerRepository.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PartnerCreated.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PartnerNameChanged.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Order.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderStatus.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderRepository.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partner/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PartnerApplicationService.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePartnerRequest.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PartnerEventListener.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DomainEventPublisher.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransactionalEventPublisher.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rest/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PartnerController.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TicketSalesApplication.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ application.properties
‚îÇ   ‚îî‚îÄ‚îÄ test/
‚îî‚îÄ‚îÄ COMPARACAO-NESTJS-SPRING.md             # Este documento
```

---

## üöÄ Como Executar

### Pr√©-requisitos
- Java 17+
- Maven 3.6+
- MySQL rodando (usar docker-compose do projeto NestJS)

### Passos

1. **Subir infraestrutura** (MySQL, Redis, RabbitMQ):
```bash
# Na raiz do projeto NestJS
docker-compose up -d
```

2. **Navegar at√© o projeto Spring**:
```bash
cd spring-ticket-sales
```

3. **Compilar projeto**:
```bash
mvn clean install
```

4. **Executar aplica√ß√£o**:
```bash
mvn spring-boot:run
```

A aplica√ß√£o estar√° dispon√≠vel em: `http://localhost:8080`

### Testando a API

#### Criar um parceiro:
```bash
curl -X POST http://localhost:8080/api/partners \
  -H "Content-Type: application/json" \
  -d '{"name": "Live Nation Brasil"}'
```

#### Listar parceiros:
```bash
curl http://localhost:8080/api/partners
```

#### Atualizar nome:
```bash
curl -X PUT http://localhost:8080/api/partners/{id}/name \
  -H "Content-Type: application/json" \
  -d '{"name": "Novo Nome"}'
```

### Logs de Eventos

Ao criar um parceiro, voc√™ ver√° nos logs:

```
‚úÖ [AFTER_COMMIT] Partner created event received: partnerId=..., name=Live Nation Brasil
```

Isso demonstra que:
1. Transa√ß√£o foi commitada
2. Evento foi publicado AP√ìS commit
3. Listener processou o evento

---

## üí° Principais Aprendizados

### O que NestJS faz que voc√™ precisa implementar manualmente:
1. ‚úçÔ∏è **Reposit√≥rios**: Implementar todos os m√©todos CRUD
2. ‚úçÔ∏è **Transa√ß√µes**: ApplicationService.run() para coordenar
3. ‚úçÔ∏è **Schemas**: Separar entidade de dom√≠nio e schema de persist√™ncia
4. ‚úçÔ∏è **Unit of Work**: Implementar interface e l√≥gica de commit/rollback
5. ‚úçÔ∏è **Eventos**: Instalar EventEmitter2 e registrar handlers manualmente
6. ‚úçÔ∏è **M√≥dulos**: Configurar providers, imports, exports em cada m√≥dulo

### O que Spring Boot faz automaticamente:
1. ‚úÖ **Reposit√≥rios**: JpaRepository gera implementa√ß√£o em runtime
2. ‚úÖ **Transa√ß√µes**: @Transactional gerencia tudo via AOP
3. ‚úÖ **Persist√™ncia**: @Entity JPA mapeia diretamente
4. ‚úÖ **Unit of Work**: EntityManager faz dirty checking autom√°tico
5. ‚úÖ **Eventos**: ApplicationEventPublisher nativo do Spring
6. ‚úÖ **Inje√ß√£o**: Component scan e inje√ß√£o autom√°tica

### Quando usar cada um:

**Use NestJS/TypeScript quando**:
- Equipe j√° conhece Node.js/JavaScript
- Precisa de alta performance em I/O ass√≠ncrono
- Quer controle fino sobre cada aspecto
- Microservi√ßos leves e r√°pidos
- Prototipagem r√°pida com TypeScript

**Use Spring Boot/Java quando**:
- Precisa de ecossistema maduro e est√°vel
- Quer menos c√≥digo boilerplate
- Equipe conhece Java/JVM
- Aplica√ß√µes enterprise complexas
- Quer conven√ß√£o sobre configura√ß√£o
- Precisa de ferramentas prontas

---

## üìö Conceitos Fundamentais

### 1. Aggregate Root
**Igual em ambos**: Classe base que mant√©m lista de eventos de dom√≠nio.

### 2. Domain Events
**Diferen√ßa**: NestJS usa EventEmitter2, Spring usa ApplicationEventPublisher nativo.

### 3. Repository Pattern
**Grande diferen√ßa**:
- NestJS: implementa√ß√£o manual
- Spring: gera√ß√£o autom√°tica via Spring Data JPA

### 4. Unit of Work
**Grande diferen√ßa**:
- NestJS: implementado manualmente com UnitOfWorkMikroOrm
- Spring: EntityManager do JPA faz automaticamente (dirty checking)

### 5. Application Service
**Grande diferen√ßa**:
- NestJS: ApplicationService.run() coordena tudo explicitamente
- Spring: @Transactional + AOP faz automaticamente

### 6. Transactional Events
**Grande diferen√ßa**:
- NestJS: ApplicationService.finish() publica ap√≥s commit manualmente
- Spring: @TransactionalEventListener(phase = AFTER_COMMIT) garante automaticamente

---

## üéì Conclus√£o

### Filosofia de Design

**NestJS**: "Explicit is better than implicit"
- Voc√™ escreve cada passo
- Mais controle, mais c√≥digo
- Sabe exatamente o que est√° acontecendo

**Spring Boot**: "Convention over configuration"
- Framework faz o trabalho pesado
- Menos c√≥digo, mais produtividade
- Precisa entender "a m√°gica" do Spring

### Produtividade

Para implementar as mesmas funcionalidades de dom√≠nio:
- **NestJS**: ~1000 linhas de c√≥digo
- **Spring**: ~300 linhas de c√≥digo

**Spring reduz ~70% do c√≥digo** atrav√©s de:
- Spring Data JPA (repositories)
- @Transactional (transa√ß√µes)
- ApplicationEventPublisher (eventos)
- Component scanning (DI)
- JPA EntityManager (Unit of Work)

### Curva de Aprendizado

**NestJS**:
- ‚úÖ Mais f√°cil se j√° conhece Node.js
- ‚úÖ C√≥digo mais expl√≠cito e did√°tico
- ‚ö†Ô∏è Precisa aprender MikroORM
- ‚ö†Ô∏è Precisa implementar muita coisa manualmente

**Spring**:
- ‚ö†Ô∏è Curva de aprendizado inicial maior
- ‚ö†Ô∏è Precisa entender "m√°gica" do Spring (proxies, AOP)
- ‚úÖ Depois que aprende, extremamente produtivo
- ‚úÖ Ecossistema enorme de solu√ß√µes prontas

### Recomenda√ß√£o

- **Aprendizado de DDD**: NestJS √© melhor (mais expl√≠cito)
- **Produtividade**: Spring √© melhor (menos c√≥digo)
- **Performance I/O**: NestJS √© melhor (Node.js ass√≠ncrono)
- **Aplica√ß√µes Enterprise**: Spring √© melhor (ecossistema maduro)

---

## üìñ Refer√™ncias

- [Spring Boot Documentation](https://spring.io/projects/spring-boot)
- [Spring Data JPA](https://spring.io/projects/spring-data-jpa)
- [NestJS Documentation](https://docs.nestjs.com/)
- [Domain-Driven Design (Eric Evans)](https://www.domainlanguage.com/ddd/)
- [Spring Transaction Management](https://docs.spring.io/spring-framework/reference/data-access/transaction.html)

---

**Autor**: Claude Code
**Data**: Janeiro 2025
**Projeto**: Compara√ß√£o NestJS vs Spring Boot - Sistema de Venda de Ingressos DDD
